package magic.core.cards.creatures;

import magic.core.IDamageable;
import magic.core.cards.Harmful;
import magic.core.cards.ICard;
import magic.core.cards.ITappable;
import magic.core.cards.Properties;
import magic.core.cards.lands.BasicLands;
import magic.core.cards.magics.attachments.DamageLifeBoost;
import magic.core.cards.magics.attachments.IAttachable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.UUID;
import java.util.stream.Collectors;

public class Creature extends Harmful implements IDamageable, IAttachable, ITappable {

    private final int life;
    private final int maxLife;
    private final Collection<Properties> properties;
    private final Collection<DamageLifeBoost> attachments;
    private final boolean tapped;

    public Creature(String name, int damage, int life,
                    Collection<BasicLands> cost) {
        this(name, damage, life, cost, Collections.emptySet());
    }

    public Creature(String name, int damage, int life,
                    Collection<BasicLands> cost,
                    Collection<Properties> properties) {
        this(name, damage, life, cost, properties, Collections.emptySet());
    }

    public Creature(String name, int damage, int life,
                    Collection<BasicLands> cost,
                    Collection<Properties> properties,
                    Collection<DamageLifeBoost> attachments) {
        this(UUID.randomUUID(), name, damage, life, life, false, cost, properties, attachments);
    }

    public Creature(UUID id, String name, int damage, int life, int maxLife,
                    boolean tapped,
                    Collection<BasicLands> cost,
                    Collection<Properties> properties,
                    Collection<DamageLifeBoost> attachments) {
        super(id, name, damage, cost);
        this.life = life;
        this.maxLife = maxLife;
        this.tapped = tapped;
        this.properties = Collections.unmodifiableCollection(properties);
        this.attachments = Collections.unmodifiableCollection(attachments);
    }

    @Override
    public IDamageable takeDamage(int damage) {
        return new Creature(id(), name(), effectiveDamage(), life - damage, maxLife,
            tapped, cost(), properties, attachments);
    }

    @Override
    public IAttachable attach(DamageLifeBoost attachment) {
        ArrayList<DamageLifeBoost> attachments = new ArrayList<>(this.attachments);
        attachments.add(attachment);

        return new Creature(id(), name(), damage(), life, maxLife,
            tapped, cost(), properties, attachments);
    }

    @Override
    public IAttachable detach(DamageLifeBoost attachment) {
        ArrayList<DamageLifeBoost> attachments = new ArrayList<>(this.attachments);
        attachments.remove(attachment);

        return new Creature(id(), name(), damage(), life, maxLife, tapped,
            cost(), properties, attachments);
    }

    @Override
    public ITappable tap() {
        return new Creature(id(), name(), damage(), life, maxLife,
            true, cost(), properties, attachments);
    }

    @Override
    public ITappable untap() {
        return new Creature(id(), name(), damage(), life, maxLife,
            false, cost(), properties, attachments);
    }

    @Override
    public boolean tapped() {
        return tapped;
    }

    /**
     * @return the base damage plus the increase generated by the attachments.
     */
    @Override
    public int effectiveDamage() {
        return super.effectiveDamage() + attachments.stream()
            .mapToInt(DamageLifeBoost::damageIncrease)
            .sum();
    }

    @Override
    public int life() {
        return life;
    }

    @Override
    public int maxLife() {
        return maxLife;
    }

    /**
     * @return the base life plus the increase generated by the attachments.
     */
    @Override
    public int effectiveLife() {
        return life() + attachments.stream()
            .mapToInt(DamageLifeBoost::lifeIncrease)
            .sum();
    }

    /**
     * @return the base max-life plus the increase generated by the attachments.
     */
    @Override
    public int effectiveMaxLife() {
        return maxLife() + attachments.stream()
            .mapToInt(DamageLifeBoost::lifeIncrease)
            .sum();
    }

    @Override
    public boolean isAlive() {
        return effectiveLife() > 0;
    }

    public Collection<Properties> properties() {
        return properties;
    }

    @Override
    public ICard duplicate() {
        return new Creature(UUID.randomUUID(), name(), damage(), life, maxLife,
            tapped, cost(), properties, attachments);
    }

    @Override
    public String toString(final boolean detailed) {
        String description
            = super.toString(detailed)
            + (life == maxLife
            ? String.format(" d:%d l:%d", effectiveDamage(), effectiveLife())
            : String.format(" d:%d l:%d/%d", effectiveDamage(), effectiveLife(), effectiveMaxLife()));

        if (detailed) {
            if (!properties.isEmpty()) {
                description += String.format(" p:{%s}", properties);
            }

            if (!attachments.isEmpty()) {
                description += String.format(" a:{%s}", attachments.stream()
                    .map(a -> a.toString(detailed))
                    .collect(Collectors.toList()));
            }
        }

        return description;
    }
}
