package magic.core.cards.creatures;

import magic.core.cards.SingleHarmful;
import magic.core.cards.lands.BasicLands;
import magic.core.cards.magics.attachments.DamageLifeBoost;
import magic.core.contracts.ICard;
import magic.core.contracts.IDamageable;
import magic.core.contracts.attachments.IAttachable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.UUID;
import java.util.stream.Collectors;

public class Creature extends SingleHarmful implements IDamageable, IAttachable {

    private final int life;
    private final int maxLife;
    private final Collection<Abilities> abilities;
    private final Collection<DamageLifeBoost> attachments;

    public Creature(String name, int damage, int life, Collection<BasicLands> cost,
                    Collection<Abilities> abilities,
                    Collection<DamageLifeBoost> attachments) {
        this(UUID.randomUUID(), name, damage, life, life, cost, abilities, attachments);
    }

    public Creature(UUID id, String name, int damage, int life, int maxLife,
                    Collection<BasicLands> cost,
                    Collection<Abilities> abilities,
                    Collection<DamageLifeBoost> attachments) {
        super(id, name, damage, cost);
        this.life = life;
        this.maxLife = maxLife;
        this.abilities = Collections.unmodifiableCollection(abilities);
        this.attachments = Collections.unmodifiableCollection(attachments);
    }

    @Override
    public IDamageable takeDamage(int damage) {
        return new Creature(id(), name(), effectiveDamage(), life - damage, maxLife,
                cost(), abilities, attachments);
    }

    @Override
    public IAttachable attach(DamageLifeBoost attachment) {
        ArrayList<DamageLifeBoost> attachments = new ArrayList<>(this.attachments);
        attachments.add(attachment);

        return new Creature(id(), name(), effectiveDamage(), life, maxLife, cost(),
                abilities, attachments);
    }

    @Override
    public IAttachable detach(DamageLifeBoost attachment) {
        ArrayList<DamageLifeBoost> attachments = new ArrayList<>(this.attachments);
        attachments.remove(attachment);

        return new Creature(id(), name(), effectiveDamage(), life, maxLife,
                cost(), abilities, attachments);
    }

    /**
     * @return the base damage plus the increase generated by the attachments.
     */
    @Override
    public int effectiveDamage() {
        return super.effectiveDamage() + attachments.stream()
                .mapToInt(DamageLifeBoost::damageIncrease)
                .sum();
    }

    @Override
    public int life() {
        return life;
    }

    @Override
    public int maxLife() {
        return maxLife;
    }

    /**
     * @return the base life plus the increase generated by the attachments.
     */
    @Override
    public int effectiveLife() {
        return life() + attachments.stream()
                .mapToInt(DamageLifeBoost::lifeIncrease)
                .sum();
    }

    /**
     * @return the base max-life plus the increase generated by the attachments.
     */
    @Override
    public int effectiveMaxLife() {
        return maxLife() + attachments.stream()
                .mapToInt(DamageLifeBoost::lifeIncrease)
                .sum();
    }

    @Override
    public boolean isAlive() {
        return effectiveLife() > 0;
    }

    public Collection<Abilities> abilities() {
        return abilities;
    }

    @Override
    public ICard duplicate() {
        return new Creature(name(), damage(), life, cost(), abilities, attachments);
    }

    @Override
    public String toString(final boolean longDescription) {
        String description
                = super.toString(longDescription)
                + (life == maxLife
                ? String.format(" d:%d l:%d", effectiveDamage(), effectiveLife())
                : String.format(" d:%d l:%d/%d", effectiveDamage(), effectiveLife(), effectiveMaxLife()));

        if (longDescription) {
            if (!abilities.isEmpty()) {
                description += String.format(" p:{%s}", abilities);
            }

            if (!attachments.isEmpty()) {
                description += String.format(" a:{%s}", attachments.stream()
                        .map(a -> a.toString(longDescription))
                        .collect(Collectors.toList()));
            }
        }

        return description;
    }
}
